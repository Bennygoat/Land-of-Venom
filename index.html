<!DOCTYPE html>
<html>
  <head>
    <title>Land of Venom</title>
    <style>
      canvas {
        background: #eee;
        display: block;
        margin: 30px auto;
      }
    </style>
    <link rel="icon" href="" />
  </head>
  <body>
    <canvas id="game" width="400" height="400"></canvas>
    <h2 style="text-align: center">Score: <span id="score">0</span></h2>
    <script>
      // 畫布設定
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      // 資料: 遊戲時間、玩家id帳號密碼、玩家得分、排名(最強玩家可以放音樂)、死亡長度、寶箱數、垃圾數
      // 待新增基礎功能:
      // 1. 碰到邊際緩速、連續扣分
      // 2. 及格邊際，一定時間內必須達到指定分數否則out
      // 3.
      // 模式1: single snake
      // 模式2: snake on snake : 寶物可以充當武器使用

      // 全域參數
      const size = 40;
      const speed = 10;
      let gameBorderX = game.width - size;
      let gameBorderY = game.height - size;
      // 狀態
      let isSlowed = false;
      let isOnBorder = false;
      let direction = "";
      const scoreBoard = document.getElementById("score");
      let score = 0;
      let borderPenalty = 1;

      // 蛇參數
      const snake = {
        body: [{ x: 180, y: 180 }],
        size: 40,
        speed: 40,
        dx: 0,
        dy: 0,
        snakeColor: "black",
      };

      // 食物參數
      const food = {
        x: 0,
        y: 0,
        size: 40,
        foodColor: "black",
        // 必須吃到時間，否則逞罰長度增加
      };

      // 寶物參數
      const treasure = {
        x: 0,
        y: 0,
        size: 20,
        // 寶物fn
        // 1. 畫布變大(最大限制，太大換獎勵)
        // 2. 速度變慢(最慢限制，太慢換獎勵)
        // 3. 長度變少(1-3，最少1，太少可以留著使用)
        // 4. 分數隨機增加(10-100)
        // 5. 時間隨機增加(1-60s)
      };

      //  大便參數
      const poop = {
        x: 0,
        y: 0,
        size: 20,
        // 大便fn ，寶物相反
        // 1. 畫布變大(最大限制，太大換獎勵)
        // 2. 速度變慢(最慢限制，太慢換獎勵)
        // 3. 長度變少(1-3，最少1，太少可以留著使用)
        // 4. 分數隨機增加(10-100)
        // 5. 時間隨機增加(1-60s)
      };

      // 取得隨機顏色
      function getRandomColor() {
        const r = Math.floor(Math.random() * 256); // 0~255
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);
        return `rgb(${r}, ${g}, ${b})`;
      }

      // 更新蛇並產生食物動作(判斷吃到，更新蛇及食物)
      function updateSnake() {
        // 新蛇頭位置
        const newHead = {
          x: snake.body[0].x + (isSlowed ? snake.dx / 12 : snake.dx / 6),
          y: snake.body[0].y + (isSlowed ? snake.dy / 12 : snake.dy / 6),
        };

        // 碰到食物加長
        if (
          Math.abs(newHead.x - food.x) < food.size &&
          Math.abs(newHead.y - food.y) < food.size
        ) {
          score += 10;
          scoreBoard.innerText = score;
          genFood();
          // 新蛇頭加到陣列前方
          snake.body.unshift(newHead);
        } else {
          // 不吃就砍尾巴，不然reqaniframe會一直想要加尾巴
          snake.body.pop();
          snake.body.unshift(newHead);
        }
        if (isSelfCollide()) {
          alert("Game Over!");
          window.location.reload();
        }
      }

      // 判斷食物蛇重疊
      function isFoodOnSnake(x, y) {
        return snake.body.some((seg) => seg.x === x && seg.y === y);
      }

      // 判斷是否自撞
      function isSelfCollide() {
        const [head, ...body] = snake.body;
        return body.some((seg) => seg.x === head.x && seg.y === head.y);
      }

      // 判斷是否在邊界需要扣分
      function applyBoarderPenalty(isOnBorder) {
        // isOnBorder === true時才執行扣分
        while (isOnBorder) {
          // 每次扣分遞延500毫秒，因為預計會放入受requestaniframe影響的draw，不遞延會很快被扣光
          setTimeout(() => {
            score -= borderPenalty;
            // 扣到0分不用再扣
            if (score <= 0) {
              score = 0;
              return;
            }
          }, 500);
        }
        // 如果isOnBorder !== true,直接return離開函式
        return;
      }

      // 判斷是否蝶家在對方身上:計算面積，可以偷取對方分數

      // 產生食物
      function genFood() {
        // 畫布內可出現的單位數
        const gridCountX = Math.floor(game.width / food.size);
        const gridCountY = Math.floor(game.height / food.size);
        // 食物參數
        // location
        let xpos, ypos;
        do {
          xpos = Math.floor(Math.random() * gridCountX) * food.size;
          ypos = Math.floor(Math.random() * gridCountY) * food.size;
        } while (isFoodOnSnake(xpos, ypos));
        // color
        food.x = xpos;
        food.y = ypos;
        do {
          food.foodColor = getRandomColor();
        } while (food.foodColor === snake.snakeColor);
        // 繪圖食物
        ctx.fillStyle = food.foodColor;
        ctx.fillRect(food.x, food.y, food.size, food.size);
      }

      // 畫蛇及食物、移動
      function draw() {
        // 畫布清除
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 邊界停止並變色
        if (
          snake.body[0].y <= 0 ||
          snake.body[0].y >= gameBorderY ||
          snake.body[0].x <= 0 ||
          snake.body[0].x >= gameBorderX
        ) {
          snake.snakeColor = getRandomColor();
          snake.body[0].y = Math.max(0, Math.min(snake.body[0].y, gameBorderY));
          snake.body[0].x = Math.max(0, Math.min(snake.body[0].x, gameBorderX));

          // 邊界降速，未來擴充扣分
          if (!isOnBorder) {
            isOnBorder = true;
            isSlowed = true;
            setTimeout(() => {
              isOnBorder = false;
              isSlowed = false;
            }, 1000);
          }
        }

        // 定義蛇的重繪顏色及速度
        // 繪圖蛇
        for (let seg of snake.body) {
          ctx.fillStyle = snake.snakeColor;
          ctx.fillRect(seg.x, seg.y, snake.size, snake.size);
        }

        // 繪圖食物
        ctx.fillStyle = food.foodColor;
        ctx.fillRect(food.x, food.y, food.size, food.size);

        // 判斷吃到，更新蛇及食物
        updateSnake();

        // 自動重新繪圖
        requestAnimationFrame(draw);
      }

      document.addEventListener("keydown", (e) => {
        switch (e.key) {
          case "ArrowUp":
            if (snake.body[0].y <= 0 || direction === "down") {
              return;
            }
            direction = "up";
            snake.dy = -snake.speed;
            snake.dx = 0;
            break;
          case "ArrowDown":
            if (snake.body[0].y >= gameBorderY || direction === "up") {
              return;
            }
            direction = "down";
            snake.dy = snake.speed;
            snake.dx = 0;
            break;
          case "ArrowLeft":
            if (snake.body[0].x <= 0 || direction === "right") {
              return;
            }
            direction = "left";
            snake.dx = -snake.speed;
            snake.dy = 0;
            break;
          case "ArrowRight":
            if (snake.body[0].x >= gameBorderX || direction === "left") {
              return;
            }
            direction = "right";
            snake.dx = snake.speed;
            snake.dy = 0;
            break;
        }
      });

      // 執行
      genFood();
      draw();
    </script>
  </body>
</html>
